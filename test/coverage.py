#!/usr/bin/env python3
"""
Check that all Note classes are generated by the test suite.
"""

import sys
import pytest
from typing import Set, types, Dict, Any, Type

from httplint.note import Note
from test.utils import checkSubClasses

import ast
import os
import re
from collections import defaultdict

# Tracking set for covered notes
covered_notes: Set[types.ModuleType] = set()
static_missing_vars: Dict[str, Set[str]] = defaultdict(set)

# Map note name to class for static analysis
note_name_to_class: Dict[str, Type[Note]] = {}

# Monkeypatch Note.__init__ to track coverage
original_init = Note.__init__

def tracking_init(self: Note, subject: str, **vars: Any) -> None:
    covered_notes.add(self.__class__)
    original_init(self, subject, **vars)

Note.__init__ = tracking_init


def collect_defined_notes() -> Set[types.ModuleType]:
    """
    Collect all defined Note subclasses.
    """
    defined_notes = set()

    def collector(note_cls):
         # Skip the base Note class if strictly subclass checking, 
         # but checkSubClasses walks subclasses.
         # We want concrete Note classes.
         # Assuming all subclasses of Note are concrete enough or intended to be used.
         # We might want to filter out intermediate base classes if any.
         # For now, let's collect all.
         defined_notes.add(note_cls)
         note_name_to_class[note_cls.__name__] = note_cls
         return 0

    paths = ["redbot", "redbot/resource", "redbot/resource/active_check"]
    checkSubClasses(Note, paths, collector)
    return defined_notes


def check_static_usage():
    """
    Statically check all python files for Note usage and missing variables.
    """
    for root, dirs, files in os.walk("redbot"):
        for file in files:
            if not file.endswith(".py"):
                continue
            
            path = os.path.join(root, file)
            try:
                with open(path, "r", encoding="utf-8") as f:
                    tree = ast.parse(f.read(), filename=path)
            except Exception as e:
                print(f"Failed to parse {path}: {e}")
                continue
            
            # Generalized walker that tracks "partial" bindings
            class ContextWalker(ast.NodeVisitor):
                def __init__(self):
                    self.current_class = None
                    # class_name -> {attr_name -> (pos_args_count, keyword_args_set)}
                    self.class_bindings = defaultdict(dict)
                    # var_name -> (pos_args_count, keyword_args_set)
                    self.local_bindings = {}

                def visit_ClassDef(self, node):
                    old_class = self.current_class
                    self.current_class = node.name
                    self.generic_visit(node)
                    self.current_class = old_class

                def visit_FunctionDef(self, node):
                    # We simply reset local bindings for each function for simplicity.
                    # This assumes no nested function shadowing complications.
                    old_locals = self.local_bindings.copy()
                    self.local_bindings = {}
                    self.generic_visit(node)
                    self.local_bindings = old_locals

                def visit_Assign(self, node):
                    # Check for lhs = partial(...)
                    if not isinstance(node.value, ast.Call):
                        self.generic_visit(node)
                        return
                    
                    # Check if call is to 'partial'
                    is_partial = False
                    if isinstance(node.value.func, ast.Name) and node.value.func.id == "partial":
                        is_partial = True
                    # We could also check for functools.partial but 'partial' is the common usage
                    
                    if is_partial:
                        # Count bound positionals and keywords
                        bound_pos = len(node.value.args) - 1 # first arg to partial is the func itself
                        if bound_pos < 0: bound_pos = 0
                        
                        bound_kws = set()
                        for kw in node.value.keywords:
                            if kw.arg:
                                bound_kws.add(kw.arg)
                        
                        binding = (bound_pos, bound_kws)
                        
                        # Apply to targets
                        for target in node.targets:
                            if isinstance(target, ast.Name):
                                self.local_bindings[target.id] = binding
                            elif isinstance(target, ast.Attribute) and \
                                 isinstance(target.value, ast.Name) and target.value.id == "self" and \
                                 self.current_class:
                                self.class_bindings[self.current_class][target.attr] = binding

                    self.generic_visit(node)

                def visit_Call(self, node):
                    # Determine if this call is relevant
                    binding = None # (bound_pos, bound_kws)
                    
                    # Case 1: Call to a local variable
                    if isinstance(node.func, ast.Name) and node.func.id in self.local_bindings:
                        binding = self.local_bindings[node.func.id]
                    
                    # Case 2: Call to self.attribute
                    elif isinstance(node.func, ast.Attribute) and \
                         isinstance(node.func.value, ast.Name) and node.func.value.id == "self" and \
                         self.current_class and node.func.attr in self.class_bindings[self.current_class]:
                        binding = self.class_bindings[self.current_class][node.func.attr]

                    # Case 3: Standard add_note call (unbound)
                    is_add_note_attr = isinstance(node.func, ast.Attribute) and node.func.attr == "add_note"
                    if not binding and not is_add_note_attr:
                        self.generic_visit(node)
                        return

                    # Default binding if not found
                    if not binding:
                        binding = (0, set()) # 0 bound pos args, 0 bound kws

                    bound_pos_count, bound_kws = binding
                    
                    # Original signature of add(self, subject, note, ...) -> note is index 1
                    # With bound_pos_count args removed from front:
                    note_arg_index = 1 - bound_pos_count
                    
                    if len(node.args) <= note_arg_index or note_arg_index < 0:
                        self.generic_visit(node)
                        return
                        
                    note_arg = node.args[note_arg_index]
                    note_name = None
                    
                    if isinstance(note_arg, ast.Name):
                        note_name = note_arg.id
                    elif isinstance(note_arg, ast.Attribute):
                         note_name = note_arg.attr
                    
                    if not note_name or note_name not in note_name_to_class:
                        self.generic_visit(node)
                        return
                        
                    note_cls = note_name_to_class[note_name]
                    
                    # Calculate needed variables
                    content = getattr(note_cls, "_summary", "") + getattr(note_cls, "_text", "")
                    needed = set(re.findall(r"%\(([^)]+)\)[diouxXeEfFgGcrsa]", content))
                    
                    if not needed:
                        self.generic_visit(node)
                        return

                    # Calculate provided variables
                    provided = set()
                    
                    # Add bound keywords
                    provided.update(bound_kws)
                    
                    # Add call keywords
                    for keyword in node.keywords:
                        if keyword.arg:
                            provided.add(keyword.arg)
                            
                    missing = needed - provided
                    if missing:
                         static_missing_vars[note_name].update(missing)
                    
                    self.generic_visit(node)

            ContextWalker().visit(tree)


if __name__ == "__main__":
    print("Collecting defined Notes...")
    defined_notes = collect_defined_notes()
    print(f"Found {len(defined_notes)} Note definitions.")

    print("Running test suite to collect coverage...")
    # Run pytest on all tests, ignoring this file to avoid infinite recursion
    # -q: quiet
    # -p no:cacheprovider: disable parsing of .pytest_cache
    pytest_args = ["test", "--ignore=test/coverage.py", "--ignore=test/test_webui.py", "-q"]
    retcode = pytest.main(pytest_args)

    if retcode != 0:
        print("Tests failed! Cannot determine coverage accurately.")
        sys.exit(retcode)

    print(f"\nCovered {len(covered_notes)} Notes.")

    missing_notes = defined_notes - covered_notes
    
    # Filter out Note itself
    if Note in missing_notes:
        missing_notes.remove(Note)

    exit_code = 0

    if missing_notes:
        print(f"\nMISSING COVERAGE: {len(missing_notes)} Notes were not generated during tests:")
        for note in sorted(missing_notes, key=lambda x: x.__name__):
            print(f"  - {note.__name__}")
        # Note: We do not fail the build for missing coverage, only for missing variables.
    
    print("\nRunning static analysis...")
    check_static_usage()
    
    if static_missing_vars:
        count = len(static_missing_vars)
        print(f"\nMISSING VARIABLES (Static): {count} Notes usages found with missing variables:")
        for note_name, vars in sorted(static_missing_vars.items()):
            print(f"  - {note_name}: {', '.join(sorted(vars))}")
        exit_code = 1

    if exit_code == 0:
        print("\nAll Notes are covered and have correct variables!")
    
    sys.exit(exit_code)
