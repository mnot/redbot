{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/node_modules/google-code-prettify/src/prettify.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","win","FLOW_CONTROL_KEYWORDS","COMMON_KEYWORDS","CPP_KEYWORDS","JAVA_KEYWORDS","CSHARP_KEYWORDS","JSCRIPT_KEYWORDS","PERL_KEYWORDS","PYTHON_KEYWORDS","RUBY_KEYWORDS","RUST_KEYWORDS","SH_KEYWORDS","C_TYPES","appendDecorations","basePos","sourceCode","langHandler","out","job","push","apply","decorations","notWs","childContentWrapper","element","wrapper","undefined","firstChild","nextSibling","type","nodeType","test","nodeValue","createSimpleLexer","shortcutStylePatterns","fallthroughStylePatterns","tokenizer","shortcuts","allPatterns","concat","allRegexs","regexKeys","length","patternParts","shortcutChars","charAt","regex","k","regexs","capturedGroupIndex","needToFoldCase","ignoreCase","source","replace","escapeCharToCodeUnit","decodeEscape","charsetPart","cc0","charCodeAt","c1","parseInt","substring","encodeEscape","charCode","toString","ch","String","fromCharCode","caseFoldCharset","charSet","charsetParts","match","RegExp","ranges","inverse","end","start","Math","max","min","sort","a","b","consolidatedRanges","lastRange","range","join","allowAnywhereFoldCaseAndRenumberGroups","parts","capturedGroups","groupIndex","decimalValue","ch0","cc","rewritten","global","multiline","Error","combinePrefixPatterns","nPatterns","decorate","pos","tokens","styleCache","ti","nTokens","isEmbedded","token","style","tokenStart","embeddedSource","embeddedSourceStart","indexOf","embeddedSourceEnd","lang","langHandlerForExtension","sourceDecorator","options","hc","regexLiterals","regexExcls","regexAny","REGEX_LITERAL","types","keywords","punctuation","decorateSource","numberLines","node","opt_startLineNum","isPreformatted","nocode","lineBreak","document","ownerDocument","li","createElement","appendChild","listItems","walk","className","text","firstLine","index","tail","parentNode","insertBefore","createTextNode","breakAfter","removeChild","nodeName","child","lineEndNode","parent","copiedListItem","breakLeftOf","limit","copy","rightSide","cloneNode","parentClone","next","sibling","setAttribute","ol","offset","langHandlerRegistry","registerLangHandler","handler","fileExtensions","ext","console","extension","applyDecorator","chunks","spans","opt_langExtension","langExtension","sourceAndSpans","sourceNode","pre","toLowerCase","isIE8OrEarlier","exec","navigator","userAgent","decPos","newlineRe","sourceLength","sourceIndex","nSpans","spanIndex","nDecorations","decorationIndex","startPos","startDec","oldDisplay","display","styledText","spanEnd","decEnd","textNode","span","replaceChild","recombineTagsAndDecorations","e","$prettyPrintOne","sourceCodeHtml","opt_numberLines","container","innerHTML","$prettyPrint","opt_whenDone","opt_root","root","body","doc","byTagName","tn","getElementsByTagName","codeSegments","elements","j","clock","Date","langExtensionRe","prettyPrintRe","prettyPrintedRe","preformattedTagNameRe","codeRe","preCodeXmpRe","EMPTY","doWork","endTime","Infinity","cs","attrs","preceder","previousSibling","nt","_","nested","tagName","preformatted","currentStyle","defaultView","whitespace","getComputedStyle","getPropertyValue","lineNums","setTimeout","PR"],"mappings":"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","file":"prettify.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// Copyright (C) 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = true;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = window;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \n      \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,final,finally,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [JAVA_KEYWORDS,\n      \"as,base,by,checked,decimal,delegate,descending,dynamic,event,\" +\n      \"fixed,foreach,from,group,implicit,in,internal,into,is,let,\" +\n      \"lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,\" +\n      \"sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,\" +\n      \"var,virtual,where\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"debugger,eval,export,function,get,null,set,undefined,var,with,\" +\n      \"Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n   var RUST_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"as,assert,const,copy,drop,\" +\n      \"enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,\" +\n      \"pub,pure,ref,self,static,struct,true,trait,type,unsafe,use\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS,\n      PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n  \n  \n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * <p>The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n  \n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n  \n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n  \n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean} isPreformatted true if white-space in text nodes should\n   *    be considered significant.\n   * @return {Object} source code and the text nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   */\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    var job = {\n      sourceCode: sourceCode,\n      basePos: basePos\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (Object)} a\n    *   function that takes source code and returns a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and produces an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @param {Object} job an object like <pre>{\n     *    sourceCode: {string} sourceText plain text,\n     *    basePos: {int} position of job.sourceCode in the larger chunk of\n     *        sourceCode.\n     * }</pre>\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {Array.<number|string>}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (Object)} a function that examines the source code\n    *     in the input job and builds the decoration list.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n      \n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, opt_startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n  \n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (opt_startLineNum === (opt_startLineNum|0)) {\n      listItems[0].setAttribute('value', opt_startLineNum);\n    }\n  \n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n  \n    node.appendChild(ol);\n  }\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {Object} job like <pre>{\n   *    sourceCode: {string} source as plain text,\n   *    sourceNode: {HTMLElement} the element containing the source,\n   *    spans: {Array.<number|Node>} alternating span start indices into source\n   *       and the text node or element (e.g. {@code <BR>}) corresponding to that\n   *       span.\n   *    decorations: {Array.<number|string} an array of style classes preceded\n   *       by the position at which they start in job.sourceCode in order\n   * }</pre>\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n  \n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n  \n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n  \n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n  \n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n  \n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n  \n    nDecorations = decorations.length = decPos;\n  \n    var sourceNode = job.sourceNode;\n    var oldDisplay;\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = spans[spanIndex + 2] || sourceLength;\n  \n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n  \n        var end = Math.min(spanEnd, decEnd);\n  \n        var textNode = spans[spanIndex + 1];\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n  \n        sourceIndex = end;\n  \n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (Object)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation.   The single parameter has the form\n    *      {@code {\n    *        sourceCode: {string} as plain text.\n    *        decorations: {Array.<number|string>} an array of style classes\n    *                     preceded by the position at which they start in\n    *                     job.sourceCode in order.\n    *                     The language handler should assigned this field.\n    *        basePos: {int} the position of source in the larger source chunk.\n    *                 All positions in the output decorations array are relative\n    *                 to the larger source chunk.\n    *      } }\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUST_KEYWORDS,\n          'cStyleComments': true,\n          'multilineStrings': true\n        }), ['rc', 'rs', 'rust']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = container.firstChild;\n    if (opt_numberLines) {\n      numberLines(container, opt_numberLines, true);\n    }\n\n    var job = {\n      langExtension: opt_langExtension,\n      numberLines: opt_numberLines,\n      sourceNode: container,\n      pre: 1\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n    var prettyPrintingJob;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint': prettyPrint =\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR; \n    });\n  }\n})();\n"],"sourceRoot":""}