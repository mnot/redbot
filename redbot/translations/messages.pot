# Translations template for PROJECT.
# Copyright (C) 2025 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2025-11-28 18:36+1100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: redbot/formatter/html.py:115
msgid "view HAR"
msgstr ""

#: redbot/formatter/html.py:118
msgid "View a HAR (HTTP ARchive, a JSON format) file for this test"
msgstr ""

#: redbot/formatter/html.py:122
msgid "check embedded"
msgstr ""

#: redbot/formatter/html.py:127
msgid "Run REDbot on images, frames and embedded links"
msgstr ""

#: redbot/formatter/html.py:188
msgid "<p class='btw'>REDbot isn't showing all content, because it's so big!</p>"
msgstr ""

#: redbot/formatter/html_base.py:137
msgid "add a request header"
msgstr ""

#: redbot/formatter/html_base.py:138
msgid "view notes"
msgstr ""

#: redbot/formatter/html_base.py:139
msgid "view body"
msgstr ""

#: redbot/formatter/html_base.py:142
#, python-format
msgid "Setting the %s request header can lead to unpredictable results."
msgstr ""

#: redbot/formatter/text.py:40
msgid "Head Links"
msgstr ""

#: redbot/formatter/text.py:41
msgid "Script Links"
msgstr ""

#: redbot/formatter/text.py:42
msgid "Frame Links"
msgstr ""

#: redbot/formatter/text.py:43
msgid "IFrame Links"
msgstr ""

#: redbot/formatter/text.py:44
msgid "Image Links"
msgstr ""

#: redbot/formatter/text.py:47
#, python-format
msgid "Error: %s\n"
msgstr ""

#: redbot/formatter/templates/footer.html:5
msgid "version"
msgstr ""

#: redbot/formatter/templates/footer.html:6
msgid "about"
msgstr ""

#: redbot/formatter/templates/footer.html:7
msgid "help"
msgstr ""

#: redbot/formatter/templates/footer.html:8
msgid "Drag the bookmarklet to your bookmark bar - it makes checking easy!"
msgstr ""

#: redbot/formatter/templates/footer.html:10
msgid "drag me to your toolbar to use REDbot any time."
msgstr ""

#: redbot/formatter/templates/footer.html:10
msgid "bookmarklet"
msgstr ""

#: redbot/formatter/templates/footer.html:14
msgid "This site is protected by hCaptcha and its"
msgstr ""

#: redbot/formatter/templates/footer.html:15
msgid "Privacy Policy"
msgstr ""

#: redbot/formatter/templates/footer.html:15
msgid "and"
msgstr ""

#: redbot/formatter/templates/footer.html:16
msgid "Terms of Service"
msgstr ""

#: redbot/formatter/templates/footer.html:16
msgid "apply."
msgstr ""

#: redbot/formatter/templates/response_finish.html:16
msgid ""
"These are the response headers; hover over each one for an explanation of"
" what it does."
msgstr ""

#: redbot/formatter/templates/response_finish.html:23
msgid ""
"Here, you can see the response body, a HAR document for the request, and "
"when appropriate,\n"
"                validate the response or check its assets (such as "
"referenced images, stylesheets and scripts)."
msgstr ""

#: redbot/formatter/templates/response_finish.html:27
msgid "How large the response headers are, including the status line"
msgstr ""

#: redbot/formatter/templates/response_finish.html:28
msgid "response headers"
msgstr ""

#: redbot/formatter/templates/response_finish.html:28
#: redbot/formatter/templates/response_finish.html:31
#: redbot/formatter/templates/response_finish.html:36
msgid "bytes"
msgstr ""

#: redbot/formatter/templates/response_finish.html:30
msgid "How large the response content is"
msgstr ""

#: redbot/formatter/templates/response_finish.html:30
msgid "content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:34
msgid "How much using chunked encoding adds to the response size"
msgstr ""

#: redbot/formatter/templates/response_finish.html:35
msgid "transfer overhead"
msgstr ""

#: redbot/formatter/templates/response_finish.html:41
msgid "View this response content (with any gzip compression removed)"
msgstr ""

#: redbot/formatter/templates/response_finish.html:42
msgid "view content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:53
#: redbot/formatter/templates/response_multi_finish.html:99
msgid "Save these results for future reference"
msgstr ""

#: redbot/formatter/templates/response_finish.html:54
#: redbot/formatter/templates/response_multi_finish.html:100
msgid "save"
msgstr ""

#: redbot/formatter/templates/response_finish.html:59
msgid "Validate the response body with a third party service"
msgstr ""

#: redbot/formatter/templates/response_finish.html:60
msgid "validate content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:75
msgid ""
"These notes explain what REDbot has found about your URL; hover over\n"
"                each one for a detailed explanation."
msgstr ""

#: redbot/formatter/templates/response_finish.html:103
msgid "If something doesn't seem right, feel free to"
msgstr ""

#: redbot/formatter/templates/response_finish.html:104
msgid "file an issue"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:3
msgid "The URI tested. Click to run a detailed analysis."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:3
msgid "URI"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:4
msgid "The HTTP status code returned."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:4
msgid "status"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:5
msgid "The size of the response content, in bytes."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:5
msgid "size"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:6
msgid "Whether a shared (e.g., proxy) cache can store the response."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:6
msgid "shared"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:7
msgid "Whether a private (e.g., browser) cache can store the response."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:7
msgid "private"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:8
msgid "How long the response had been cached before REDbot got it."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:8
msgid "age"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:9
msgid "How long a cache can treat the response as fresh."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:9
msgid "freshness"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:10
msgid "Whether If-Modified-Since validation is supported, using Last-Modified."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:10
msgid "IMS"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:11
msgid "Whether If-None-Match validation is supported, using ETags."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:11
msgid "INM"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:13
msgid ""
"Whether negotiation for gzip compression is supported; if so, the percent"
" of the original size saved."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:14
msgid "gzip"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:15
msgid "Whether partial responses are supported."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:15
msgid "partial"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:16
msgid "Issues encountered."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:16
msgid "notes"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:82
msgid "response incomplete"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:84
msgid "unknown problem"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:108
msgid "Notes"
msgstr ""

#: redbot/formatter/templates/response_start.html:31
msgid "REDbot is lint for your HTTP resources."
msgstr ""

#: redbot/formatter/templates/response_start.html:37
msgid "Lint for your HTTP resources"
msgstr ""

#: redbot/formatter/templates/response_start.html:59
msgid ""
"Type in a URI here and press 'return' to check it. You can also specify "
"request headers by clicking 'add a request header.'"
msgstr ""

#: redbot/formatter/templates/response_start.html:61
msgid "Enter a http:// or https:// URL to check"
msgstr ""

#: redbot/resource/fetch.py:293
msgid "This response has content."
msgstr ""

#: redbot/resource/fetch.py:294
#, python-format
msgid ""
"HTTP defines a few special situations where a response does not allow "
"content. This includes 101,\n"
"204 and 304 responses, as well as responses to the `HEAD` method.\n"
"\n"
"This response had data after the headers ended, despite it being "
"disallowed. Clients receiving it\n"
"may treat the content as the next response in the connection, leading to "
"interoperability and\n"
"security issues.\n"
"\n"
"The extra data started with:\n"
"\n"
"    %(sample)s\n"
msgstr ""

#: redbot/resource/fetch.py:311
msgid "This response has extra data after it."
msgstr ""

#: redbot/resource/fetch.py:312
#, python-format
msgid ""
"The server sent data after the message ended. This can be caused by an "
"incorrect `Content-Length`\n"
"header, or by a programming error in the server itself.\n"
"\n"
"The extra data started with:\n"
"\n"
"    %(sample)s\n"
msgstr ""

#: redbot/resource/fetch.py:325
msgid "This response has chunked encoding errors."
msgstr ""

#: redbot/resource/fetch.py:326
#, python-format
msgid ""
"The response indicates it uses HTTP chunked encoding, but there was a "
"problem decoding the\n"
"chunking.\n"
"\n"
"A valid chunk looks something like this:\n"
"\n"
"    [chunk-size in hex]\\r\\n[chunk-data]\\r\\n\n"
"\n"
"However, the chunk sent started like this:\n"
"\n"
"    %(chunk_sample)s\n"
"\n"
"This is a serious problem, because HTTP uses chunking to delimit one "
"response from the next one;\n"
"incorrect chunking can lead to interoperability and security problems.\n"
"\n"
"This issue is often caused by sending an integer chunk size instead of "
"one in hex, or by sending\n"
"`Transfer-Encoding: chunked` without actually chunking the response body."
msgstr ""

#: redbot/resource/fetch.py:348
#, python-format
msgid ""
"This response has whitespace at the end of the '%(header_name)s' header "
"field name."
msgstr ""

#: redbot/resource/fetch.py:349
msgid ""
"HTTP specifically bans whitespace between header field names and the "
"colon, because they can easily\n"
"be confused by recipients; some will strip it, and others won't, leading "
"to a variety of attacks.\n"
"\n"
"Most HTTP implementations will refuse to process this message.\n"
msgstr ""

#: redbot/resource/fetch.py:171
#, python-format
msgid "fetching %(uri)s (%(check_name)s)"
msgstr ""

#: redbot/resource/active_check/base.py:100
msgid "This response is missing required headers."
msgstr ""

#: redbot/resource/active_check/base.py:101
#, python-format
msgid ""
"HTTP requires `304 Not Modified` responses to have certain headers, if "
"they are also present in a\n"
"normal (e.g., `200 OK` response).\n"
"\n"
"This response is missing the following headers: `%(missing_hdrs)s`.\n"
"\n"
"This can affect cache operation; because the headers are missing, caches "
"might remove them from\n"
"their cached copies."
msgstr ""

#: redbot/resource/active_check/conneg.py:145
msgid "There was a problem checking for Content Negotiation support."
msgstr ""

#: redbot/resource/active_check/conneg.py:146
#, python-format
msgid ""
"When REDbot tried to check the resource for content negotiation support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/conneg.py:157
#, python-format
msgid ""
"Content negotiation for gzip compression is supported, saving "
"%(savings)s%%."
msgstr ""

#: redbot/resource/active_check/conneg.py:160
#, python-format
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource provided one, saving %(savings)s%% of"
" its original size (from\n"
"%(orig_size)s to %(gzip_size)s bytes).\n"
"\n"
"The compressed response's headers are displayed."
msgstr ""

#: redbot/resource/active_check/conneg.py:171
#, python-format
msgid ""
"Content negotiation for gzip compression makes the response %(savings)s%%"
" larger."
msgstr ""

#: redbot/resource/active_check/conneg.py:172
#, python-format
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource provided one, but it was "
"%(savings)s%% _larger_ than the\n"
"original response; from %(orig_size)s to %(gzip_size)s bytes.\n"
"\n"
"Often, this happens when the uncompressed response is very small, or "
"can't be compressed more;\n"
"since gzip compression has some overhead, it can make the response "
"larger. Turning compression\n"
"**off** for this resource may slightly improve response times and save "
"bandwidth.\n"
"\n"
"The compressed response's headers are displayed."
msgstr ""

#: redbot/resource/active_check/conneg.py:187
msgid "Content negotiation for gzip compression isn't supported."
msgstr ""

#: redbot/resource/active_check/conneg.py:188
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource did not provide one."
msgstr ""

#: redbot/resource/active_check/conneg.py:196
msgid ""
"The compressed response is negotiated, but doesn't have an appropriate "
"Vary header."
msgstr ""

#: redbot/resource/active_check/conneg.py:197
msgid ""
"All content negotiated responses need to have a `Vary` header that "
"reflects the header(s) used to\n"
"select the response.\n"
"\n"
"The compressed response was negotiated for `gzip` content encoding, so "
"the `Vary` header needs to contain\n"
"`Accept-Encoding`, the request header used."
msgstr ""

#: redbot/resource/active_check/conneg.py:208
msgid "A gzip-compressed response was sent when it wasn't asked for."
msgstr ""

#: redbot/resource/active_check/conneg.py:209
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. Even though RED\n"
"didn't ask for a compressed response, the resource provided one anyway.\n"
"\n"
"It could be that the response is always compressed, but doing so can "
"break clients that aren't\n"
"expecting a compressed response."
msgstr ""

#: redbot/resource/active_check/conneg.py:220
msgid "The resource doesn't send Vary consistently."
msgstr ""

#: redbot/resource/active_check/conneg.py:221
#, python-format
msgid ""
"HTTP requires that the `Vary` response header be sent consistently for "
"all responses if they change\n"
"based upon different aspects of the request.\n"
"\n"
"This resource has both compressed and uncompressed variants available, "
"negotiated by the\n"
"`Accept-Encoding` request header, but it sends different Vary headers for"
" each;\n"
"\n"
"* \"`%(conneg_vary)s`\" when the response is compressed, and\n"
"* \"`%(no_conneg_vary)s`\" when it is not.\n"
"\n"
"This can cause problems for downstream caches, because they cannot "
"consistently determine what the\n"
"cache key for a given URI is."
msgstr ""

#: redbot/resource/active_check/conneg.py:238
msgid "The response status is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:239
#, python-format
msgid ""
"When content negotiation is used, the response status shouldn't change "
"between negotiated and\n"
"non-negotiated responses.\n"
"\n"
"When REDbot send asked for a negotiated response, it got a "
"`%(neg_status)s` status code; when it\n"
"didn't, it got `%(noneg_status)s`.\n"
"\n"
"REDbot hasn't checked other aspects of content negotiation because of "
"this."
msgstr ""

#: redbot/resource/active_check/conneg.py:252
#, python-format
msgid "The %(header)s header is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:253
#, python-format
msgid ""
"When content negotiation is used, the %(header)s response header "
"shouldn't change between\n"
"negotiated and non-negotiated responses."
msgstr ""

#: redbot/resource/active_check/conneg.py:261
msgid "The response content is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:262
msgid ""
"When content negotiation is used, the response content typically "
"shouldn't change between negotiated\n"
"and non-negotiated responses.\n"
"\n"
"There might be legitimate reasons for this; e.g., because different "
"servers handled the two\n"
"requests. However, RED's output may be skewed as a result."
msgstr ""

#: redbot/resource/active_check/conneg.py:273
msgid "The ETag doesn't change between negotiated representations."
msgstr ""

#: redbot/resource/active_check/conneg.py:274
msgid ""
"HTTP requires that the `ETag`s for two different responses associated "
"with the same URI be\n"
"different as well, to help caches and other receivers disambiguate them.\n"
"\n"
"This resource, however, sent the same strong ETag for both its compressed"
" and uncompressed versions\n"
"(negotiated by `Accept-Encoding`). This can cause interoperability "
"problems, especially with caches.\n"
"\n"
"Note that some versions of the Apache HTTP Server sometimes send the same"
" ETag for both\n"
"compressed and uncompressed versions of a resource. This is a [known\n"
"bug](https://issues.apache.org/bugzilla/show_bug.cgi?id=39727)."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:91
msgid "There was a problem checking for ETag validation support."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:92
#, python-format
msgid ""
"When REDbot tried to check the resource for ETag validation support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:103
msgid "If-None-Match conditional requests are supported."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:104
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation. REDbot has done this and found that the resource sends a "
"`304 Not Modified`\n"
"response, indicating that it supports `ETag` validation."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:114
msgid "An If-None-Match conditional request returned the full content unchanged."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:116
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation.\n"
"\n"
"REDbot has done this and found that the resource sends the same, full "
"response even though it hadn't\n"
"changed, indicating that it doesn't support `ETag` validation."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:128
#: redbot/resource/active_check/etag_validate.py:145
msgid ""
"During validation, the ETag didn't change, even though the response "
"content did."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:129
msgid ""
"`ETag`s are supposed to uniquely identify the response representation; if"
" the content changes, so\n"
"should the ETag.\n"
"\n"
"However, HTTP allows reuse of an `ETag` if it's \"weak\", as long as the "
"server is OK with the two\n"
"different responses being considered as interchangeable by clients.\n"
"\n"
"For example, if a small detail of a Web page changes, and it doesn't "
"affect the overall meaning of\n"
"the page, you can use the same weak `ETag` to identify both versions.\n"
"\n"
"If the changes are important, a different `ETag` should be used."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:146
#, python-format
msgid ""
"`ETag`s are supposed to uniquely identify the response representation; if"
" the content changes, so\n"
"should the ETag.\n"
"\n"
"Here, the same `ETag` was used for two different responses during "
"validation, which means that\n"
"downstream clients and caches might confuse them.\n"
"\n"
"If the changes between the two representations aren't important (i.e., "
"they can be used\n"
"interchangeably), they can share a \"weak\" ETag; to do that, just "
"prepend `W/`, to make its value\n"
"`W/%(etag)s`. Otherwise, they need to use different `ETag`s."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:161
msgid ""
"An If-None-Match conditional request returned the full content, but it "
"had changed."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:162
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation.\n"
"\n"
"REDbot has done this, but the response changed between the original "
"request and the validating\n"
"request, so REDbot can't tell whether or not `ETag` validation is "
"supported."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:174
#, python-format
msgid "An If-None-Match conditional request returned a %(inm_status)s status."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:175
#, python-format
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation. REDbot has done this, but the response had a "
"%(enc_inm_status)s status code, so RED\n"
"can't tell whether or not `ETag` validation is supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:107
msgid "There was a problem checking for Last-Modified validation support."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:108
#, python-format
msgid ""
"When REDbot tried to check the resource for Last-Modified validation "
"support, there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:119
msgid "If-Modified-Since conditional requests are supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:120
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this and found that the resource sends a `304 Not "
"Modified` response, indicating\n"
"that it supports `Last-Modified` validation."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:132
msgid ""
"An If-Modified-Since conditional request returned the full content "
"unchanged."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:135
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this and found that the resource sends a full response "
"even though it hadn't\n"
"changed, indicating that it doesn't support `Last-Modified` validation."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:147
msgid ""
"An If-Modified-Since conditional request returned the full content, but "
"it had changed."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:151
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this, but the response changed between the original "
"request and the validating\n"
"request, so REDbot can't tell whether or not `Last-Modified` validation "
"is supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:163
#, python-format
msgid "An If-Modified-Since conditional request returned a %(ims_status)s status."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:166
#, python-format
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this, but the response had a %(enc_ims_status)s status "
"code, so REDbot can't tell\n"
"whether or not `Last-Modified` validation is supported."
msgstr ""

#: redbot/resource/active_check/range.py:132
msgid "There was a problem checking for Partial Content support."
msgstr ""

#: redbot/resource/active_check/range.py:133
#, python-format
msgid ""
"When REDbot tried to check the resource for partial content support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/range.py:144
msgid "The resource advertises support for non-standard range-units."
msgstr ""

#: redbot/resource/active_check/range.py:145
msgid ""
"The `Accept-Ranges` response header tells clients what `range-unit`s a "
"resource is willing to\n"
"process in future requests. HTTP only defines two: `bytes` and `none`.\n"
"\n"
"Clients who don't know about the non-standard range-unit will not be able"
" to use it."
msgstr ""

#: redbot/resource/active_check/range.py:155
msgid "A ranged request returned the correct partial content."
msgstr ""

#: redbot/resource/active_check/range.py:156
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of it should be sent. REDbot has tested"
" this by requesting part of\n"
"this response, which was returned correctly."
msgstr ""

#: redbot/resource/active_check/range.py:165
msgid "A ranged request returned partial content, but it was incorrect."
msgstr ""

#: redbot/resource/active_check/range.py:166
#, python-format
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of the response should be sent. REDbot "
"has tested this by\n"
"requesting part of this response, but the partial response doesn't "
"correspond with the full\n"
"response retrieved at the same time. This could indicate that the range "
"implementation isn't\n"
"working properly.\n"
"\n"
"REDbot sent:\n"
"\n"
"> Range: %(range)s\n"
"\n"
"REDbot expected %(range_expected_bytes)s bytes:\n"
"\n"
"> %(range_expected).100s\n"
"\n"
"REDbot received %(range_received_bytes)s bytes:\n"
"\n"
"> %(range_received).100s\n"
"\n"
"_(showing samples of up to 100 characters)_"
msgstr ""

#: redbot/resource/active_check/range.py:191
msgid "A ranged request returned another representation."
msgstr ""

#: redbot/resource/active_check/range.py:192
msgid ""
"A new representation was retrieved when checking support of ranged "
"request. This is not an error,\n"
"it just indicates that REDbot cannot draw any conclusion at this time."
msgstr ""

#: redbot/resource/active_check/range.py:200
msgid "A ranged request returned the full rather than partial content."
msgstr ""

#: redbot/resource/active_check/range.py:201
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of the response should be sent. REDbot "
"has tested this by\n"
"requesting part of this response, but the entire response was returned. "
"In other words, although\n"
"the resource advertises support for partial content, it doesn't appear to"
" actually do so."
msgstr ""

#: redbot/resource/active_check/range.py:211
#, python-format
msgid "A ranged request returned a %(range_status)s status."
msgstr ""

#: redbot/resource/active_check/range.py:212
#, python-format
msgid ""
"This resource advertises support for ranged requests; that is, it allows "
"clients to specify that\n"
"only part of the response should be sent. REDbot has tested this by "
"requesting part of this\n"
"response, but a %(enc_range_status)s response code was returned, which "
"REDbot was not expecting."
msgstr ""

#: redbot/resource/active_check/range.py:221
msgid ""
"Partial responses don't have the same support for compression that full "
"ones do."
msgstr ""

#: redbot/resource/active_check/range.py:222
msgid ""
"This resource supports ranged requests and also supports negotiation for "
"gzip compression, but\n"
"doesn't support compression for both full and partial responses.\n"
"\n"
"This can cause problems for clients when they compare the partial and "
"full responses, since the\n"
"partial response is expressed as a byte range, and compression changes "
"the bytes."
msgstr ""

#: redbot/resource/active_check/range.py:233
msgid "The partial response is missing required headers."
msgstr ""

#: redbot/resource/active_check/range.py:234
#, python-format
msgid ""
"HTTP requires `206 Partial Content` responses to have certain headers, if"
" they are also present in\n"
"a normal (e.g., `200 OK` response).\n"
"\n"
"The partial response is missing the following headers: "
"`%(missing_hdrs)s`.\n"
"\n"
"This can affect cache operation; because the headers are missing, caches "
"might remove them from\n"
"their stored copies."
msgstr ""

#: redbot/translations/extra_strings.py:8
msgid "General"
msgstr ""

#: redbot/translations/extra_strings.py:9
msgid "Browser Security"
msgstr ""

#: redbot/translations/extra_strings.py:10
msgid "Content Negotiation"
msgstr ""

#: redbot/translations/extra_strings.py:11
msgid "Caching"
msgstr ""

#: redbot/translations/extra_strings.py:12
msgid "Validation"
msgstr ""

#: redbot/translations/extra_strings.py:13
msgid "Connection"
msgstr ""

#: redbot/translations/extra_strings.py:14
msgid "Partial Content"
msgstr ""

