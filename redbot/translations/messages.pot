#: redbot/formatter/html.py:118
msgid "view HAR"
msgstr ""

#: redbot/formatter/html.py:121
msgid "View a HAR (HTTP ARchive, a JSON format) file for this test"
msgstr ""

#: redbot/formatter/html.py:125
msgid "check embedded"
msgstr ""

#: redbot/formatter/html.py:130
msgid "Run REDbot on images, frames and embedded links"
msgstr ""

#: redbot/formatter/html.py:191
msgid "<p class='btw'>REDbot isn't showing all content, because it's so big!</p>"
msgstr ""

#: redbot/formatter/html.py:203
#, python-format
msgid "%s response"
msgstr ""

#: redbot/formatter/html.py:215
#, python-format
msgid " - %d problem\n"
msgstr ""

#: redbot/formatter/html_base.py:136
msgid "add a request header"
msgstr ""

#: redbot/formatter/html_base.py:137
msgid "view notes"
msgstr ""

#: redbot/formatter/html_base.py:138
msgid "view body"
msgstr ""

#: redbot/formatter/html_base.py:139
#: redbot/formatter/templates/response_finish.html:86
msgid "sort by alpha"
msgstr ""

#: redbot/formatter/html_base.py:140
msgid "show wire order"
msgstr ""

#: redbot/formatter/html_base.py:143
#, python-format
msgid "Setting the %s request header can lead to unpredictable results."
msgstr ""

#: redbot/formatter/text.py:40
msgid "Head Links"
msgstr ""

#: redbot/formatter/text.py:41
msgid "Script Links"
msgstr ""

#: redbot/formatter/text.py:42
msgid "Frame Links"
msgstr ""

#: redbot/formatter/text.py:43
msgid "IFrame Links"
msgstr ""

#: redbot/formatter/text.py:44
msgid "Image Links"
msgstr ""

#: redbot/formatter/text.py:47
#, python-format
msgid "Error: %s\n"
msgstr ""

#: redbot/formatter/templates/footer.html:5
msgid "version"
msgstr ""

#: redbot/formatter/templates/footer.html:6
msgid "about"
msgstr ""

#: redbot/formatter/templates/footer.html:7
msgid "help"
msgstr ""

#: redbot/formatter/templates/footer.html:8
msgid "Drag the bookmarklet to your bookmark bar - it makes checking easy!"
msgstr ""

#: redbot/formatter/templates/footer.html:10
msgid "drag me to your toolbar to use REDbot any time."
msgstr ""

#: redbot/formatter/templates/footer.html:10
msgid "bookmarklet"
msgstr ""

#: redbot/formatter/templates/footer.html:14
msgid "This site is protected by hCaptcha and its"
msgstr ""

#: redbot/formatter/templates/footer.html:15
msgid "Privacy Policy"
msgstr ""

#: redbot/formatter/templates/footer.html:15
msgid "and"
msgstr ""

#: redbot/formatter/templates/footer.html:16
msgid "Terms of Service"
msgstr ""

#: redbot/formatter/templates/footer.html:16
msgid "apply."
msgstr ""

#: redbot/formatter/templates/response_finish.html:22
msgid ""
"These are the response headers; hover over each one for an explanation of"
" what it does."
msgstr ""

#: redbot/formatter/templates/response_finish.html:31
msgid ""
"Here, you can see the response body, a HAR document for the request, and "
"when appropriate,\n"
"                validate the response or check its assets (such as "
"referenced images, stylesheets and scripts)."
msgstr ""

#: redbot/formatter/templates/response_finish.html:35
msgid "How large the response headers are, including the status line"
msgstr ""

#: redbot/formatter/templates/response_finish.html:36
msgid "response headers"
msgstr ""

#: redbot/formatter/templates/response_finish.html:36
#: redbot/formatter/templates/response_finish.html:39
#: redbot/formatter/templates/response_finish.html:44
msgid "bytes"
msgstr ""

#: redbot/formatter/templates/response_finish.html:38
msgid "How large the response content is"
msgstr ""

#: redbot/formatter/templates/response_finish.html:38
msgid "content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:42
msgid "How much using chunked encoding adds to the response size"
msgstr ""

#: redbot/formatter/templates/response_finish.html:43
msgid "transfer overhead"
msgstr ""

#: redbot/formatter/templates/response_finish.html:49
msgid "View this response content (with any gzip compression removed)"
msgstr ""

#: redbot/formatter/templates/response_finish.html:50
msgid "view content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:60
#: redbot/formatter/templates/response_multi_finish.html:105
msgid "This result is saved"
msgstr ""

#: redbot/formatter/templates/response_finish.html:61
#: redbot/formatter/templates/response_multi_finish.html:106
#, python-brace-format
msgid "Saved until {0} from now"
msgstr ""

#: redbot/formatter/templates/response_finish.html:67
#: redbot/formatter/templates/response_multi_finish.html:99
msgid "Save these results for future reference"
msgstr ""

#: redbot/formatter/templates/response_finish.html:68
#: redbot/formatter/templates/response_multi_finish.html:100
msgid "save"
msgstr ""

#: redbot/formatter/templates/response_finish.html:73
msgid "Validate the response body with a third party service"
msgstr ""

#: redbot/formatter/templates/response_finish.html:74
msgid "validate content"
msgstr ""

#: redbot/formatter/templates/response_finish.html:85
msgid "Header sorting"
msgstr ""

#: redbot/formatter/templates/response_finish.html:93
msgid ""
"These notes explain what REDbot has found about your URL; hover over\n"
"                each one for a detailed explanation."
msgstr ""

#: redbot/formatter/templates/response_finish.html:121
msgid "If something doesn't seem right, feel free to"
msgstr ""

#: redbot/formatter/templates/response_finish.html:122
msgid "file an issue"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:3
msgid "The URI tested. Click to run a detailed analysis."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:3
msgid "URI"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:4
msgid "The HTTP status code returned."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:4
msgid "status"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:5
msgid "The size of the response content, in bytes."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:5
msgid "size"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:6
msgid "Whether a shared (e.g., proxy) cache can store the response."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:6
msgid "shared"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:7
msgid "Whether a private (e.g., browser) cache can store the response."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:7
msgid "private"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:8
msgid "How long the response had been cached before REDbot got it."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:8
msgid "age"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:9
msgid "How long a cache can treat the response as fresh."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:9
msgid "freshness"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:10
msgid "Whether If-Modified-Since validation is supported, using Last-Modified."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:10
msgid "IMS"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:11
msgid "Whether If-None-Match validation is supported, using ETags."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:11
msgid "INM"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:13
msgid ""
"Whether negotiation for gzip compression is supported; if so, the percent"
" of the original size saved."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:14
msgid "gzip"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:15
msgid "Whether partial responses are supported."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:15
msgid "partial"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:16
msgid "Issues encountered."
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:16
msgid "notes"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:82
msgid "response incomplete"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:84
msgid "unknown problem"
msgstr ""

#: redbot/formatter/templates/response_multi_finish.html:114
msgid "Notes"
msgstr ""

#: redbot/formatter/templates/response_start.html:31
msgid "REDbot is lint for your HTTP resources."
msgstr ""

#: redbot/formatter/templates/response_start.html:37
msgid "Lint for your HTTP resources"
msgstr ""

#: redbot/formatter/templates/response_start.html:59
msgid ""
"Type in a URI here and press 'return' to check it. You can also specify "
"request headers by clicking 'add a request header.'"
msgstr ""

#: redbot/formatter/templates/response_start.html:61
msgid "Enter a http:// or https:// URL to check"
msgstr ""

#: redbot/resource/fetch.py:311
msgid "This response has content."
msgstr ""

#: redbot/resource/fetch.py:312
#, python-format
msgid ""
"HTTP defines a few special situations where a response does not allow "
"content. This includes 101,\n"
"204 and 304 responses, as well as responses to the `HEAD` method.\n"
"\n"
"This response had data after the headers ended, despite it being "
"disallowed. Clients receiving it\n"
"may treat the content as the next response in the connection, leading to "
"interoperability and\n"
"security issues.\n"
"\n"
"The extra data started with:\n"
"\n"
"    %(sample)s\n"
msgstr ""

#: redbot/resource/fetch.py:329
msgid "This response has extra data after it."
msgstr ""

#: redbot/resource/fetch.py:330
#, python-format
msgid ""
"The server sent data after the message ended. This can be caused by an "
"incorrect `Content-Length`\n"
"header, or by a programming error in the server itself.\n"
"\n"
"The extra data started with:\n"
"\n"
"    %(sample)s\n"
msgstr ""

#: redbot/resource/fetch.py:343
msgid "This response has chunked encoding errors."
msgstr ""

#: redbot/resource/fetch.py:344
#, python-format
msgid ""
"The response indicates it uses HTTP chunked encoding, but there was a "
"problem decoding the\n"
"chunking.\n"
"\n"
"A valid chunk looks something like this:\n"
"\n"
"    [chunk-size in hex]\\r\\n[chunk-data]\\r\\n\n"
"\n"
"However, the chunk sent started like this:\n"
"\n"
"    %(chunk_sample)s\n"
"\n"
"This is a serious problem, because HTTP uses chunking to delimit one "
"response from the next one;\n"
"incorrect chunking can lead to interoperability and security problems.\n"
"\n"
"This issue is often caused by sending an integer chunk size instead of "
"one in hex, or by sending\n"
"`Transfer-Encoding: chunked` without actually chunking the response body."
msgstr ""

#: redbot/resource/fetch.py:366
#, python-format
msgid ""
"This response has whitespace at the end of the '%(header_name)s' header "
"field name."
msgstr ""

#: redbot/resource/fetch.py:367
msgid ""
"HTTP specifically bans whitespace between header field names and the "
"colon, because they can easily\n"
"be confused by recipients; some will strip it, and others won't, leading "
"to a variety of attacks.\n"
"\n"
"Most HTTP implementations will refuse to process this message.\n"
msgstr ""

#: redbot/resource/fetch.py:378
#, python-format
msgid "The %(response)s response contains a %(header_name)s header."
msgstr ""

#: redbot/resource/fetch.py:379
#, python-format
msgid ""
"RFC 9110 requires that 1xx responses not contain a `%(header_name)s` "
"header.\n"
"\n"
"Clients receiving this response will either fail to process it or behave "
"unexpectedly.\n"
msgstr ""

#: redbot/resource/fetch.py:171
#, python-format
msgid "fetching %(uri)s (%(check_name)s)"
msgstr ""

#: redbot/resource/active_check/base.py:100
msgid "This response is missing required headers."
msgstr ""

#: redbot/resource/active_check/base.py:101
#, python-format
msgid ""
"HTTP requires `304 Not Modified` responses to have certain headers, if "
"they are also present in a\n"
"normal (e.g., `200 OK` response).\n"
"\n"
"This response is missing the following headers: `%(missing_hdrs)s`.\n"
"\n"
"This can affect cache operation; because the headers are missing, caches "
"might remove them from\n"
"their cached copies."
msgstr ""

#: redbot/resource/active_check/conneg.py:150
msgid "There was a problem checking for Content Negotiation support."
msgstr ""

#: redbot/resource/active_check/conneg.py:151
#, python-format
msgid ""
"When REDbot tried to check the resource for content negotiation support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/conneg.py:162
#, python-format
msgid ""
"Content negotiation for gzip compression is supported, saving "
"%(savings)s%%."
msgstr ""

#: redbot/resource/active_check/conneg.py:165
#, python-format
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource provided one, saving %(savings)s%% of"
" its original size (from\n"
"%(orig_size)s to %(gzip_size)s bytes).\n"
"\n"
"The compressed response's headers are displayed."
msgstr ""

#: redbot/resource/active_check/conneg.py:176
#, python-format
msgid ""
"Content negotiation for gzip compression makes the response %(savings)s%%"
" larger."
msgstr ""

#: redbot/resource/active_check/conneg.py:177
#, python-format
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource provided one, but it was "
"%(savings)s%% _larger_ than the\n"
"original response; from %(orig_size)s to %(gzip_size)s bytes.\n"
"\n"
"Often, this happens when the uncompressed response is very small, or "
"can't be compressed more;\n"
"since gzip compression has some overhead, it can make the response "
"larger. Turning compression\n"
"**off** for this resource may slightly improve response times and save "
"bandwidth.\n"
"\n"
"The compressed response's headers are displayed."
msgstr ""

#: redbot/resource/active_check/conneg.py:192
msgid "Content negotiation for gzip compression isn't supported."
msgstr ""

#: redbot/resource/active_check/conneg.py:193
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. When REDbot asked for\n"
"a compressed response, the resource did not provide one."
msgstr ""

#: redbot/resource/active_check/conneg.py:201
msgid ""
"The compressed response is negotiated, but doesn't have an appropriate "
"Vary header."
msgstr ""

#: redbot/resource/active_check/conneg.py:202
msgid ""
"All content negotiated responses need to have a `Vary` header that "
"reflects the header(s) used to\n"
"select the response.\n"
"\n"
"The compressed response was negotiated for `gzip` content encoding, so "
"the `Vary` header needs to contain\n"
"`Accept-Encoding`, the request header used."
msgstr ""

#: redbot/resource/active_check/conneg.py:213
msgid "A gzip-compressed response was sent when it wasn't asked for."
msgstr ""

#: redbot/resource/active_check/conneg.py:214
msgid ""
"HTTP supports compression of responses by negotiating for `Content-"
"Encoding`. Even though RED\n"
"didn't ask for a compressed response, the resource provided one anyway.\n"
"\n"
"It could be that the response is always compressed, but doing so can "
"break clients that aren't\n"
"expecting a compressed response."
msgstr ""

#: redbot/resource/active_check/conneg.py:225
msgid "The resource doesn't send Vary consistently."
msgstr ""

#: redbot/resource/active_check/conneg.py:226
#, python-format
msgid ""
"HTTP requires that the `Vary` response header be sent consistently for "
"all responses if they change\n"
"based upon different aspects of the request.\n"
"\n"
"This resource has both compressed and uncompressed variants available, "
"negotiated by the\n"
"`Accept-Encoding` request header, but it sends different Vary headers for"
" each;\n"
"\n"
"* \"`%(conneg_vary)s`\" when the response is compressed, and\n"
"* \"`%(no_conneg_vary)s`\" when it is not.\n"
"\n"
"This can cause problems for downstream caches, because they cannot "
"consistently determine what the\n"
"cache key for a given URI is."
msgstr ""

#: redbot/resource/active_check/conneg.py:243
msgid "The response status is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:244
#, python-format
msgid ""
"When content negotiation is used, the response status shouldn't change "
"between negotiated and\n"
"non-negotiated responses.\n"
"\n"
"When REDbot send asked for a negotiated response, it got a "
"`%(neg_status)s` status code; when it\n"
"didn't, it got `%(noneg_status)s`.\n"
"\n"
"REDbot hasn't checked other aspects of content negotiation because of "
"this."
msgstr ""

#: redbot/resource/active_check/conneg.py:257
#, python-format
msgid "The %(header)s header is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:258
#, python-format
msgid ""
"When content negotiation is used, the %(header)s response header "
"shouldn't change between\n"
"negotiated and non-negotiated responses.\n"
"\n"
"* Negotiated: `%(negotiated_val)s`\n"
"* Non-negotiated: `%(bare_val)s`"
msgstr ""

#: redbot/resource/active_check/conneg.py:269
msgid "The response content is different when content negotiation happens."
msgstr ""

#: redbot/resource/active_check/conneg.py:270
msgid ""
"When content negotiation is used, the response content typically "
"shouldn't change between negotiated\n"
"and non-negotiated responses.\n"
"\n"
"There might be legitimate reasons for this; e.g., because different "
"servers handled the two\n"
"requests. However, RED's output may be skewed as a result."
msgstr ""

#: redbot/resource/active_check/conneg.py:281
msgid "The ETag doesn't change between negotiated representations."
msgstr ""

#: redbot/resource/active_check/conneg.py:282
msgid ""
"HTTP requires that the `ETag`s for two different responses associated "
"with the same URI be\n"
"different as well, to help caches and other receivers disambiguate them.\n"
"\n"
"This resource, however, sent the same strong ETag for both its compressed"
" and uncompressed versions\n"
"(negotiated by `Accept-Encoding`). This can cause interoperability "
"problems, especially with caches.\n"
"\n"
"Note that some versions of the Apache HTTP Server sometimes send the same"
" ETag for both\n"
"compressed and uncompressed versions of a resource. This is a [known\n"
"bug](https://issues.apache.org/bugzilla/show_bug.cgi?id=39727)."
msgstr ""

#: redbot/resource/active_check/conneg.py:19
#: redbot/translations/extra_strings.py:10
msgid "Content Negotiation"
msgstr ""

#: redbot/resource/active_check/conneg.py:20
msgid "The compressed response"
msgstr ""

#: redbot/resource/active_check/etag_validate.py:94
msgid "There was a problem checking for ETag validation support."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:95
#, python-format
msgid ""
"When REDbot tried to check the resource for ETag validation support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:106
msgid "If-None-Match conditional requests are supported."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:107
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation. REDbot has done this and found that the resource sends a "
"`304 Not Modified`\n"
"response, indicating that it supports `ETag` validation."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:117
msgid "An If-None-Match conditional request returned the full content unchanged."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:119
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation.\n"
"\n"
"REDbot has done this and found that the resource sends the same, full "
"response even though it hadn't\n"
"changed, indicating that it doesn't support `ETag` validation."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:131
#: redbot/resource/active_check/etag_validate.py:148
msgid ""
"During validation, the ETag didn't change, even though the response "
"content did."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:132
msgid ""
"`ETag`s are supposed to uniquely identify the response representation; if"
" the content changes, so\n"
"should the ETag.\n"
"\n"
"However, HTTP allows reuse of an `ETag` if it's \"weak\", as long as the "
"server is OK with the two\n"
"different responses being considered as interchangeable by clients.\n"
"\n"
"For example, if a small detail of a Web page changes, and it doesn't "
"affect the overall meaning of\n"
"the page, you can use the same weak `ETag` to identify both versions.\n"
"\n"
"If the changes are important, a different `ETag` should be used."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:149
#, python-format
msgid ""
"`ETag`s are supposed to uniquely identify the response representation; if"
" the content changes, so\n"
"should the ETag.\n"
"\n"
"Here, the same `ETag` was used for two different responses during "
"validation, which means that\n"
"downstream clients and caches might confuse them.\n"
"\n"
"If the changes between the two representations aren't important (i.e., "
"they can be used\n"
"interchangeably), they can share a \"weak\" ETag; to do that, just "
"prepend `W/`, to make its value\n"
"`W/%(etag)s`. Otherwise, they need to use different `ETag`s."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:164
msgid ""
"An If-None-Match conditional request returned the full content, but it "
"had changed."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:165
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation.\n"
"\n"
"REDbot has done this, but the response changed between the original "
"request and the validating\n"
"request, so REDbot can't tell whether or not `ETag` validation is "
"supported."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:177
#, python-format
msgid "An If-None-Match conditional request returned a %(inm_status)s status."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:178
#, python-format
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has an `ETag`, clients should be able to use an `If-"
"None-Match` request header\n"
"for validation. REDbot has done this, but the response had a "
"%(enc_inm_status)s status code, so RED\n"
"can't tell whether or not `ETag` validation is supported."
msgstr ""

#: redbot/resource/active_check/etag_validate.py:18
msgid "ETag Validation"
msgstr ""

#: redbot/resource/active_check/etag_validate.py:19
msgid "The ETag validation response"
msgstr ""

#: redbot/resource/active_check/lm_validate.py:110
msgid "There was a problem checking for Last-Modified validation support."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:111
#, python-format
msgid ""
"When REDbot tried to check the resource for Last-Modified validation "
"support, there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:122
msgid "If-Modified-Since conditional requests are supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:123
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this and found that the resource sends a `304 Not "
"Modified` response, indicating\n"
"that it supports `Last-Modified` validation."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:135
msgid ""
"An If-Modified-Since conditional request returned the full content "
"unchanged."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:138
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this and found that the resource sends a full response "
"even though it hadn't\n"
"changed, indicating that it doesn't support `Last-Modified` validation."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:150
msgid ""
"An If-Modified-Since conditional request returned the full content, but "
"it had changed."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:154
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this, but the response changed between the original "
"request and the validating\n"
"request, so REDbot can't tell whether or not `Last-Modified` validation "
"is supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:166
#, python-format
msgid "An If-Modified-Since conditional request returned a %(ims_status)s status."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:169
#, python-format
msgid ""
"HTTP allows clients to make conditional requests to see if a copy that "
"they hold is still valid.\n"
"Since this response has a `Last-Modified` header, clients should be able "
"to use an\n"
"`If-Modified-Since` request header for validation.\n"
"\n"
"REDbot has done this, but the response had a %(enc_ims_status)s status "
"code, so REDbot can't tell\n"
"whether or not `Last-Modified` validation is supported."
msgstr ""

#: redbot/resource/active_check/lm_validate.py:20
msgid "Last-Modified Validation"
msgstr ""

#: redbot/resource/active_check/lm_validate.py:21
msgid "The Last-Modified validation response"
msgstr ""

#: redbot/resource/active_check/range.py:148
msgid "There was a problem checking for Partial Content support."
msgstr ""

#: redbot/resource/active_check/range.py:149
#, python-format
msgid ""
"When REDbot tried to check the resource for partial content support, "
"there was a problem:\n"
"\n"
"`%(problem)s`\n"
"\n"
"Trying again might fix it."
msgstr ""

#: redbot/resource/active_check/range.py:160
msgid "The resource advertises support for non-standard range-units."
msgstr ""

#: redbot/resource/active_check/range.py:161
msgid ""
"The `Accept-Ranges` response header tells clients what `range-unit`s a "
"resource is willing to\n"
"process in future requests. HTTP only defines two: `bytes` and `none`.\n"
"\n"
"Clients who don't know about the non-standard range-unit will not be able"
" to use it."
msgstr ""

#: redbot/resource/active_check/range.py:171
msgid "A ranged request returned the correct partial content."
msgstr ""

#: redbot/resource/active_check/range.py:172
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of it should be sent. REDbot has tested"
" this by requesting part of\n"
"this response, which was returned correctly."
msgstr ""

#: redbot/resource/active_check/range.py:181
msgid "A ranged request returned partial content, but it was incorrect."
msgstr ""

#: redbot/resource/active_check/range.py:182
#, python-format
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of the response should be sent. REDbot "
"has tested this by\n"
"requesting part of this response, but the partial response doesn't "
"correspond with the full\n"
"response retrieved at the same time. This could indicate that the range "
"implementation isn't\n"
"working properly.\n"
"\n"
"REDbot sent:\n"
"\n"
"> Range: %(range)s\n"
"\n"
"REDbot expected %(range_expected_bytes)s bytes:\n"
"\n"
"> %(range_expected).100s\n"
"\n"
"REDbot received %(range_received_bytes)s bytes:\n"
"\n"
"> %(range_received).100s\n"
"\n"
"_(showing samples of up to 100 characters)_"
msgstr ""

#: redbot/resource/active_check/range.py:207
msgid "A ranged request returned another representation."
msgstr ""

#: redbot/resource/active_check/range.py:208
msgid ""
"A new representation was retrieved when checking support of ranged "
"request. This is not an error,\n"
"it just indicates that REDbot cannot draw any conclusion at this time."
msgstr ""

#: redbot/resource/active_check/range.py:216
msgid "A ranged request returned the full rather than partial content."
msgstr ""

#: redbot/resource/active_check/range.py:217
msgid ""
"This resource advertises support for ranged requests with `Accept-"
"Ranges`; that is, it allows\n"
"clients to specify that only part of the response should be sent. REDbot "
"has tested this by\n"
"requesting part of this response, but the entire response was returned. "
"In other words, although\n"
"the resource advertises support for partial content, it doesn't appear to"
" actually do so."
msgstr ""

#: redbot/resource/active_check/range.py:227
#, python-format
msgid "A ranged request returned a %(range_status)s status."
msgstr ""

#: redbot/resource/active_check/range.py:228
#, python-format
msgid ""
"This resource advertises support for ranged requests; that is, it allows "
"clients to specify that\n"
"only part of the response should be sent. REDbot has tested this by "
"requesting part of this\n"
"response, but a %(enc_range_status)s response code was returned, which "
"REDbot was not expecting."
msgstr ""

#: redbot/resource/active_check/range.py:237
msgid ""
"Partial responses don't have the same support for compression that full "
"ones do."
msgstr ""

#: redbot/resource/active_check/range.py:238
msgid ""
"This resource supports ranged requests and also supports negotiation for "
"gzip compression, but\n"
"doesn't support compression for both full and partial responses.\n"
"\n"
"This can cause problems for clients when they compare the partial and "
"full responses, since the\n"
"partial response is expressed as a byte range, and compression changes "
"the bytes."
msgstr ""

#: redbot/resource/active_check/range.py:249
msgid "The partial response is missing required headers."
msgstr ""

#: redbot/resource/active_check/range.py:250
#, python-format
msgid ""
"HTTP requires `206 Partial Content` responses to have certain headers, if"
" they are also present in\n"
"a normal (e.g., `200 OK` response).\n"
"\n"
"The partial response is missing the following headers: "
"`%(missing_hdrs)s`.\n"
"\n"
"This can affect cache operation; because the headers are missing, caches "
"might remove them from\n"
"their stored copies."
msgstr ""

#: redbot/resource/active_check/range.py:263
msgid "The partial response has a Content-Length equal to the full response."
msgstr ""

#: redbot/resource/active_check/range.py:264
msgid ""
"The `Content-Length` header in a 206 response should indicate the size of"
" the partial content, not\n"
"the full response. This response has a `Content-Length` that matches the "
"full size of the response,\n"
"which suggests it might be incorrect."
msgstr ""

#: redbot/resource/active_check/range.py:273
msgid "The Content-Range header indicates an incorrect total length."
msgstr ""

#: redbot/resource/active_check/range.py:274
msgid ""
"The `Content-Range` header in a 206 response indicates the total length "
"of the response. In this\n"
"case, it doesn't match the `Content-Length` of the full response, which "
"suggests one of them is\n"
"incorrect."
msgstr ""

#: redbot/resource/active_check/range.py:28
#: redbot/translations/extra_strings.py:14
msgid "Partial Content"
msgstr ""

#: redbot/resource/active_check/range.py:29
msgid "The partial response"
msgstr ""

#: redbot/translations/extra_strings.py:8
msgid "General"
msgstr ""

#: redbot/translations/extra_strings.py:9
msgid "Browser Security"
msgstr ""

#: redbot/translations/extra_strings.py:11
msgid "Caching"
msgstr ""

#: redbot/translations/extra_strings.py:12
msgid "Validation"
msgstr ""

#: redbot/translations/extra_strings.py:13
msgid "Connection"
msgstr ""

